// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GrpcService.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "GrpcService.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GrpcServiceRoot

@implementation GrpcServiceRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - GrpcServiceRoot_FileDescriptor

static GPBFileDescriptor *GrpcServiceRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"snaplink_grpc"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Empty

@implementation Empty


typedef struct Empty__storage_ {
  uint32_t _has_storage_[1];
} Empty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Empty class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Empty__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Matrix

@implementation Matrix

@dynamic rows;
@dynamic cols;
@dynamic dataArray, dataArray_Count;

typedef struct Matrix__storage_ {
  uint32_t _has_storage_[1];
  uint32_t rows;
  uint32_t cols;
  GPBFloatArray *dataArray;
} Matrix__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rows",
        .dataTypeSpecific.className = NULL,
        .number = Matrix_FieldNumber_Rows,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Matrix__storage_, rows),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cols",
        .dataTypeSpecific.className = NULL,
        .number = Matrix_FieldNumber_Cols,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Matrix__storage_, cols),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dataArray",
        .dataTypeSpecific.className = NULL,
        .number = Matrix_FieldNumber_DataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Matrix__storage_, dataArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Matrix class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Matrix__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CameraModel

@implementation CameraModel

@dynamic fx;
@dynamic fy;
@dynamic cx;
@dynamic cy;

typedef struct CameraModel__storage_ {
  uint32_t _has_storage_[1];
  float fx;
  float fy;
  float cx;
  float cy;
} CameraModel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fx",
        .dataTypeSpecific.className = NULL,
        .number = CameraModel_FieldNumber_Fx,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CameraModel__storage_, fx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "fy",
        .dataTypeSpecific.className = NULL,
        .number = CameraModel_FieldNumber_Fy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CameraModel__storage_, fy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "cx",
        .dataTypeSpecific.className = NULL,
        .number = CameraModel_FieldNumber_Cx,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CameraModel__storage_, cx),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "cy",
        .dataTypeSpecific.className = NULL,
        .number = CameraModel_FieldNumber_Cy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CameraModel__storage_, cy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CameraModel class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CameraModel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Label

@implementation Label

@dynamic dbId;
@dynamic x;
@dynamic y;
@dynamic z;
@dynamic name;

typedef struct Label__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dbId;
  float x;
  float y;
  float z;
  NSString *name;
} Label__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dbId",
        .dataTypeSpecific.className = NULL,
        .number = Label_FieldNumber_DbId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Label__storage_, dbId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = Label_FieldNumber_X,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Label__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = Label_FieldNumber_Y,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Label__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "z",
        .dataTypeSpecific.className = NULL,
        .number = Label_FieldNumber_Z,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Label__storage_, z),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Label_FieldNumber_Name,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Label__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Label class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Label__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Labels

@implementation Labels

@dynamic labelsArray, labelsArray_Count;

typedef struct Labels__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *labelsArray;
} Labels__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "labelsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Label),
        .number = Labels_FieldNumber_LabelsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Labels__storage_, labelsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Labels class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Labels__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Item

@implementation Item

@dynamic name;
@dynamic x;
@dynamic y;
@dynamic size;

typedef struct Item__storage_ {
  uint32_t _has_storage_[1];
  float x;
  float y;
  float size;
  NSString *name;
} Item__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = Item_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Item__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "x",
        .dataTypeSpecific.className = NULL,
        .number = Item_FieldNumber_X,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Item__storage_, x),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "y",
        .dataTypeSpecific.className = NULL,
        .number = Item_FieldNumber_Y,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Item__storage_, y),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = Item_FieldNumber_Size,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Item__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Item class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Item__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LocalizationRequest

@implementation LocalizationRequest

@dynamic requestId;
@dynamic image;
@dynamic orientation;
@dynamic hasCamera, camera;

typedef struct LocalizationRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t orientation;
  NSData *image;
  CameraModel *camera;
  uint64_t requestId;
} LocalizationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationRequest_FieldNumber_RequestId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LocalizationRequest__storage_, requestId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationRequest_FieldNumber_Image,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LocalizationRequest__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "orientation",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationRequest_FieldNumber_Orientation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LocalizationRequest__storage_, orientation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "camera",
        .dataTypeSpecific.className = GPBStringifySymbol(CameraModel),
        .number = LocalizationRequest_FieldNumber_Camera,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LocalizationRequest__storage_, camera),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocalizationRequest class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LocalizationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LocalizationResponse

@implementation LocalizationResponse

@dynamic requestId;
@dynamic success;
@dynamic dbId;
@dynamic hasPose, pose;
@dynamic itemsArray, itemsArray_Count;
@dynamic width;
@dynamic height;
@dynamic angle;
@dynamic width0;
@dynamic height0;

typedef struct LocalizationResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dbId;
  uint32_t width;
  uint32_t height;
  uint32_t angle;
  Matrix *pose;
  NSMutableArray *itemsArray;
  uint64_t requestId;
  double width0;
  double height0;
} LocalizationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationResponse_FieldNumber_RequestId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, requestId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "success",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationResponse_FieldNumber_Success,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dbId",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationResponse_FieldNumber_DbId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, dbId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pose",
        .dataTypeSpecific.className = GPBStringifySymbol(Matrix),
        .number = LocalizationResponse_FieldNumber_Pose,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, pose),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "itemsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Item),
        .number = LocalizationResponse_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationResponse_FieldNumber_Width,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, width),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationResponse_FieldNumber_Height,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, height),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "angle",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationResponse_FieldNumber_Angle,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, angle),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "width0",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationResponse_FieldNumber_Width0,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, width0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "height0",
        .dataTypeSpecific.className = NULL,
        .number = LocalizationResponse_FieldNumber_Height0,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LocalizationResponse__storage_, height0),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocalizationResponse class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LocalizationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLabelsResponse

@implementation GetLabelsResponse

@dynamic labelsMap, labelsMap_Count;

typedef struct GetLabelsResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt32ObjectDictionary *labelsMap;
} GetLabelsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "labelsMap",
        .dataTypeSpecific.className = GPBStringifySymbol(Labels),
        .number = GetLabelsResponse_FieldNumber_LabelsMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetLabelsResponse__storage_, labelsMap),
        .flags = GPBFieldMapKeyUInt32,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLabelsResponse class]
                                     rootClass:[GrpcServiceRoot class]
                                          file:GrpcServiceRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLabelsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
